#define STEPS 64
#define STEP_SIZE 0.01
#define MIN_DISTANCE 0.1
#define MAX_DISTANCE 2.0
vec3 rotA = vec3(radians(-45.0),0,0);
const float angle1 = cos(radians(-15.0));
const float angle2 = sin(radians(-15.0));
mat3 view = mat3(vec3(1,0,0),
                 vec3(0,angle1,-angle2),
                vec3(0,angle2,angle1));
//view[0][0] = cos(rotA[0]);//vec4(cos(rotA[0]), -sin(rotA[0]) ,0,0);
//view[1] = vec4(sin(rotA[0]), cos(rotA[0]) ,0,0);
vec3 centre = vec3(0,1,6);
float radius = 1.0; 

float sphereDistance(vec3 p) {
    return distance(p, centre) - radius;
}
float sceneDistance(vec3 p){
	float floor = p.y;
    float sDist = sphereDistance(p);
    return min(floor,sDist);
}

float raymarch(vec4 position, vec4 direction) {
    float d = 0.0;
    for (int i = 0; i < STEPS; i++) {
        vec3 rayP = position.xyz + d*direction.xyz;
        float distance = sceneDistance(rayP);//sphereDistance(rayP);//sphereDistance(position);
        d += distance;
        if (distance < MIN_DISTANCE && d < MAX_DISTANCE){
            //vec4 retColor = vec4(1,0,0,1);
            //retColor.w = 1;
            return d; //1-(i / float(STEPS))
        }
        //STEP_SIZE;
    }
    return d; //was originally 1
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = (gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;

    // Time varying pixel color
    vec3 col = vec3(0,10.0*uv.x,10.0*uv.y);
    
    vec3 point = vec3(0,1,0);
  	//point.z -= iTime*0.1;
    vec3 ray = view*normalize(vec3(uv.x,uv.y,1));
	
    // Output to screen
    float d = raymarch(vec4(point,1),vec4(ray,1));
    d /= 6.;
    fragColor = vec4(vec3(d),1);
        
}